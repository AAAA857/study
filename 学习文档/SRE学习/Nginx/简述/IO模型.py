'''
同步/异步： 关注的是消息通信机制，即每次调用事情的处理结果是实时返回还是阻塞等待
    同步: 被调用者不会提供消息的相关通知消息，需要调用者主动询问事件
    异步： 被调用者通过状态通知回调，调用者不需要主动去询问事件状态，当收到处理事件后继续处理

阻塞/非阻塞： 调用者关注被调用者执行状态
    阻塞：   执行的任务将会挂起，不会往下继续执行
    非阻塞: 任务发起后不会挂起，调用者可以继续执行其他任务


IO模型:
    同步阻塞:   发起一个任务后调用者将等待，需要不停的询问任务执行状态
    同步非阻塞:  发起一个任务后调用者可以做其他事情，但是要不间断的询问任务是否完成，在这一轮的间隔时间内可以做其他事情
    异步阻塞:   发起一个任务后调用者不可以做其他的事情，调用者不需要询问任务执行状态，在任务执行完成后会通知调用者
    异步非阻塞:  发起一个任务后调用者可以做其他的事情，不需要询问任务执行状态，在任务执行完成后会通知调用者，调用者过来继续处理任务，取数据的过程是阻塞


'''


'''
    # 同步阻塞
    client 发起系统调用 --------> 内核 无数据准备
                                |
                                |
                                +数据报文准备完成
                                |
                                |
    client 处理数据     <---------+复制数据
    
    # 异步非阻塞
    client 发起系统调用 -------> 内核 无数据准备
                             |                   
                      <------+ 不阻塞 无数据
                             |
    client 发起系统调用 ------>+
                             | 
                      <------+ 不阻塞 无数据
                             |
    client 发起系统调用 ------>+ 数据报文准备完成 
                             |              
                             |
                             + 拷贝数据（内核态转换用户态）
                             |
    client 处理数据     <------+ 拷贝完成
    
    # I/O多路复用
    # 上述模型中，每个文件描述符对应一个I/O都由一个线程监控和处理
    # 多路复用指一个线程可以同时(实际交替实现，并发完成)监控和处理多个文件描述符对应的各自I/O即服用一个线程
    # 要实现这种IO多路服用功能，要调用内核中的select、POLL或EPOLL机制来实现
    # select: select 是一个I/O多路服用模型，同步阻塞方式进程阻塞在调用select处，受限系统常量FD_SETSIZE=1024(文件描述符集合)限制，不适合大规模并发场景
    client Process 发起select调用   ------>  内核 无数据准备
    阻塞                                  |
    阻塞                                  + select 会监听描述符列表中是否存在已经完成的描述符
    阻塞                                  | 
    阻塞                                  + select 会监听描述符列表中是否存在已经完成的描述符
    回调通知                        <----- + 监听到描述符有变化
    client Process 发起select调用   ------>+ 拷贝数据内核态
    阻                                    |
    client Process 处理数据包       <------ + 数据拷贝完成用户态
          
    # 信号驱动event: 异步方式，用户进程可以通过发起一个sigaction系统调用组测进去,然后进程继续往下执行，当内核中的数据准备完成，将会通过信号方式通知
    进程来取数据，不受文件描述符限制,缺点大量信号IO可能会导致信号队列溢出从而导致不能发送通知
    
    client Process (sigaction) 发起系统调用 ----> 内核 无数据准备
    非阻塞                                     |
    非阻塞                                     + 无数据
    非阻塞                                     |
    非阻塞                                     + 无数据
    非阻塞                                     |    
    非阻塞                                     + 数据发送变化
    非阻塞                                     |
                                    <---sigIO + 通知client
    发起调用                          --------> + 拷贝数据  内核态
    阻塞                                       |
    处理数据                           <--------+ 拷贝完成 用户态
    
    # 异步非阻塞: 掉用者和被调用者都是不阻塞的，当任务处理完成内核会通知进程，其中数据也不需要做拷贝(零拷贝)内核功能，调用者可以直接读取数据
    
'''


